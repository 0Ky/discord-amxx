#include <amxmodx>
#include <amxmisc>
#include <sockets>
#include <winsocketerr>
#include <json>

#pragma semicolon 1
#pragma dynamic 2097152

#define PLUGIN_NAME "Socket Chat Relay"
#define PLUGIN_VERSION "1.6.0"
#define PLUGIN_AUTHOR "C.ix"

#define HOST "127.0.0.1"
#define PORT 57412

#define MAX_BUFFER_LENGTH 2048
#if !defined MAX_NAME_LENGTH
#define MAX_NAME_LENGTH 32
#endif

#define TASK_LISTEN 1246500
#define TASK_RECONNECT 1246510
#define TASK_SEND_READY 1246520
#define TASK_SEND_SLOTINFO 1246530

// #define IsUUIDv4(%1) bool:!!(strlen(%1) == 36 && (%1[8] == '-') && (%1[13] == '-') && (%1[18] == '-') && (%1[23] == '-') && (%1[14] == '4') && (strfind("89ab", %1[19], true) != -1) && IsHexWithDashes(%1))
// #define ishex(%0) bool:!!( ( '0' <= %0 <= '9' || 'a' <= %0 <= 'f' || 'A' <= %0 <= 'F' ))

new Float:g_fCooldown[MAX_PLAYERS + 1] = {0.0, ...};

enum MessageType
{
    MSG_INVALID = 0,
    MSG_HANDSHAKE,
    MSG_CHAT,
    // MSG_CHATSUPPORT,
    MSG_SLASH,
    MSG_LINK,
    MSG_SLOTINFO
};

new g_hSocket = -1;
new g_SharedSecret;
new g_Challenge[256];
new bool:g_bAuthenticated = false;
new bool:g_bBotReady;


public plugin_init()
{
    register_plugin(PLUGIN_NAME, PLUGIN_VERSION, PLUGIN_AUTHOR);
    register_clcmd("say", "handleSay");
    register_clcmd("say_team", "handleSay");
    register_clcmd("verify", "cmdVerify");

    g_SharedSecret = create_cvar("scr_shared_secret", "", FCVAR_SPONLY | FCVAR_PROTECTED, "The shared secret generated by the Discord bot");

    establish_connection();
}

public establish_connection()
{
    socket_close(g_hSocket);
    new iErrorCode;
    g_bBotReady = false;

    g_hSocket = socket_open(HOST, PORT, SOCKET_TCP, iErrorCode, SOCK_NON_BLOCKING|SOCK_LIBC_ERRORS);

    new szErrorMsg[32];
    GetSocketErrorMessage(iErrorCode, szErrorMsg, charsmax(szErrorMsg));

    if (iErrorCode != 0 && !equal(szErrorMsg, "WSAEWOULDBLOCK"))
    {
        server_print("[%s] Error: %s", PLUGIN_NAME, szErrorMsg);
        set_task(5.0, "establish_connection", TASK_RECONNECT);
        return PLUGIN_CONTINUE;
    }

    if (send_handshake())
        set_task(1.0, "listen_for_data", TASK_LISTEN, _, _, "b");

    return PLUGIN_CONTINUE;
}

bool:send_handshake()
{
    if (g_hSocket > 0 && socket_is_writable(g_hSocket, 0))
    {
        new JSON:jsonMsgObj = json_init_object();
        json_object_set_number(jsonMsgObj, "type", _:MSG_HANDSHAKE);
        json_object_set_string(jsonMsgObj, "status", "HANDSHAKE_HELLO");

        new szReadyMessage[MAX_BUFFER_LENGTH];
        json_serial_to_string(jsonMsgObj, szReadyMessage, charsmax(szReadyMessage), false);

        server_print("[%s] Sending data: %s", PLUGIN_NAME, szReadyMessage);

        new iSentBytes = socket_send2(g_hSocket, szReadyMessage, strlen(szReadyMessage));
        json_free(jsonMsgObj);

        if (iSentBytes < 0)
        {
            set_task(1.0, "send_handshake", TASK_SEND_READY);
            return false;
        }
        else
            return true;
    }
    else
        set_task(1.0, "establish_connection", TASK_RECONNECT);
    return false;
}

public listen_for_data()
{
    if (g_hSocket == -1 || !socket_is_readable(g_hSocket, 0))
        return PLUGIN_CONTINUE;

    new szData[MAX_BUFFER_LENGTH];
    new iBytesReceived = socket_recv(g_hSocket, szData, charsmax(szData));

    if (iBytesReceived > 0)
    {
        server_print("[%s] Received data: %s", PLUGIN_NAME, szData);

        new JSON:jsonResponse = json_parse(szData);
        if (json_is_object(jsonResponse))
        {
            if (!json_object_has_value(jsonResponse, "type", JSONNumber))
            {
                server_print("[%s] Missing 'type' key in JSON message.", PLUGIN_NAME);
                json_free(jsonResponse);
                return PLUGIN_CONTINUE;
            }

            new iMsgType = json_object_get_number(jsonResponse, "type");

            switch (iMsgType)
            {
                case MSG_HANDSHAKE: { if (!g_bBotReady) process_handshake(jsonResponse); }
                case MSG_CHAT: { listen_msg_chat(jsonResponse); }
                case MSG_SLASH: { listen_msg_slash(jsonResponse); }
                case MSG_LINK: { listen_msg_link(jsonResponse); }
                default: { server_print("[%s] Unknown or unsupported message type: %d", PLUGIN_NAME, iMsgType); }
            }
        }
        json_free(jsonResponse);
    }
    else
    {
        if (iBytesReceived == 0)
            server_print("[%s] Connection closed by server.", PLUGIN_NAME); // This condition never triggered because of non-blocking mode
        else
            server_print("[%s] Error reading from socket: %d", PLUGIN_NAME, iBytesReceived); // instead this is called...

        remove_task(TASK_LISTEN);
        remove_task(TASK_SEND_SLOTINFO);
        set_task(1.0, "establish_connection", TASK_RECONNECT);
    }
    return PLUGIN_CONTINUE;
}

process_challenge()
{
    new szSharedSecret[256];
    new szCombined[512];

    get_pcvar_string(g_SharedSecret, szSharedSecret, charsmax(szSharedSecret));

    formatex(szCombined, charsmax(szCombined), "%s%s", g_Challenge, szSharedSecret);
    static szExpectedHash[512];
    hash_string(szCombined, Hash_Keccak_256, szExpectedHash, charsmax(szExpectedHash));

    // server_print("nonce: %s",g_Challenge);
    // server_print("shared secret: %s",szSharedSecret);
    // server_print("combined: %s",szCombined);
    // server_print("ExpectedHash: %s",szExpectedHash);


    new JSON:jsonMsgObj = json_init_object();
    json_object_set_number(jsonMsgObj, "type", _:MSG_HANDSHAKE);
    json_object_set_string(jsonMsgObj, "status", "HANDSHAKE_CHALLENGE");
    json_object_set_string(jsonMsgObj, "challenge", szExpectedHash);

    new szReadyMessage[MAX_BUFFER_LENGTH];
    json_serial_to_string(jsonMsgObj, szReadyMessage, charsmax(szReadyMessage), false);

    new iSentBytes = socket_send2(g_hSocket, szReadyMessage, strlen(szReadyMessage));
    json_free(jsonMsgObj);

    if (iSentBytes < 0)
    {
        server_print("[%s] Failed to send authentication response", PLUGIN_NAME);
        remove_task(TASK_LISTEN);
        set_task(1.0, "establish_connection", TASK_RECONNECT);
    }
    else
    {
        server_print("[%s] Handshake challenge sent: %s", PLUGIN_NAME, szExpectedHash);
    }

}

process_handshake(const JSON:jsonResponse)
{
    if (json_object_has_value(jsonResponse, "status", JSONString))
    {
        new szStatus[MAX_BUFFER_LENGTH];
        json_object_get_string(jsonResponse, "status", szStatus, charsmax(szStatus));

        if (equal(szStatus, "HANDSHAKE_CHALLENGE"))
        {
            if (json_object_has_value(jsonResponse, "challenge", JSONString))
            {
                new szChallenge[MAX_BUFFER_LENGTH];
                json_object_get_string(jsonResponse, "challenge", szChallenge, charsmax(szChallenge));

                if (IsHex(szChallenge))
                {
                    copy(g_Challenge, charsmax(g_Challenge), szChallenge);
                    // server_print("[%s] Received challenge: %s", PLUGIN_NAME, g_Challenge);
                    process_challenge();
                }
                else
                {
                    server_print("[%s] Invalid handshake challenge", PLUGIN_NAME);
                    g_bBotReady = false;
                    set_task(1.0, "send_handshake", TASK_SEND_READY);
                }
            }
        }
        else if (equal(szStatus, "HANDSHAKE_OK"))
        {
            server_print("[%s] Handshake challenge verified by %s:%d", PLUGIN_NAME, HOST, PORT);
            g_bBotReady = true;
            set_task(5.0, "send_slotinfo", TASK_SEND_SLOTINFO, _, _, "b");
        }
        else if (equal(szStatus, "HANDSHAKE_REJECT"))
        {
            server_print("[%s] Handshake was rejected", PLUGIN_NAME);
            g_bBotReady = false;
            set_task(1.0, "send_handshake", TASK_SEND_READY);
        }
    }
    else
        set_task(1.0, "send_handshake", TASK_SEND_READY);
}

public send_slotinfo()
{
    if (g_hSocket == -1 || !socket_is_writable(g_hSocket, 0))
        return PLUGIN_CONTINUE;


    static iPrevPlayersNum;
    static iPlayersNum; iPlayersNum = get_playersnum();
    static szPrevMaxPlayers[4];
    static szMaxPlayers[4];
    static iPcvarVisibleMaxplayers; iPcvarVisibleMaxplayers = get_cvar_pointer("sv_visiblemaxplayers");
    num_to_str(get_pcvar_num(iPcvarVisibleMaxplayers), szMaxPlayers, charsmax(szMaxPlayers));

    // Check if the values have changed since this is being called
    // every 5 seconds, only send if the values differ from last call
    // server_print("szMaxPlayers:%s,szPrevMaxPlayers:%s,iPlayersNum:%i,iPrevPlayersNum:%i",szMaxPlayers,szPrevMaxPlayers,iPlayersNum,iPrevPlayersNum);


    if (strcmp(szMaxPlayers, szPrevMaxPlayers) == 0 && iPlayersNum == iPrevPlayersNum)
        return PLUGIN_CONTINUE;

    // Update the previous values with the current ones
    // copy(dest[],len,const src[]);
    copy(szPrevMaxPlayers, charsmax(szPrevMaxPlayers), szMaxPlayers);
    iPrevPlayersNum = iPlayersNum;

    new JSON:jsonMsgObj = json_init_object();
    json_object_set_number(jsonMsgObj, "type", _:MSG_SLOTINFO);
    json_object_set_string(jsonMsgObj, "maxplayers", szMaxPlayers); // value changes because of custom reserved players logic
    json_object_set_number(jsonMsgObj, "playersnum", iPlayersNum);

    new szSerializedMessage[MAX_BUFFER_LENGTH];
    json_serial_to_string(jsonMsgObj, szSerializedMessage, charsmax(szSerializedMessage), false);
    json_free(jsonMsgObj);

    new iSentBytes = socket_send2(g_hSocket, szSerializedMessage, strlen(szSerializedMessage));
    if (iSentBytes < 0)
        server_print("[%s] Error sending data to socket", PLUGIN_NAME);
    else
        server_print("[%s] Sent message: %s", PLUGIN_NAME, szSerializedMessage);

    return PLUGIN_CONTINUE;
}


listen_msg_chat(const JSON:jsonResponse)
{
    if (!json_object_has_value(jsonResponse, "channel", JSONString) ||
        !json_object_has_value(jsonResponse, "displayname", JSONString) ||
        !json_object_has_value(jsonResponse, "message", JSONString))
    {
        server_print("[%s] Missing keys in incoming JSON message.", PLUGIN_NAME);
        return;
    }

    new szChannel[MAX_NAME_LENGTH], szDiscordName[MAX_NAME_LENGTH], szMessage[MAX_BUFFER_LENGTH];

    json_object_get_string(jsonResponse, "channel", szChannel, charsmax(szChannel));
    json_object_get_string(jsonResponse, "displayname", szDiscordName, charsmax(szDiscordName));
    json_object_get_string(jsonResponse, "message", szMessage, charsmax(szMessage));

    new szChannelNameSan[MAX_NAME_LENGTH];
    new c, iDest = 0;
    for (new i = 0; szChannel[i] != EOS; i++)
    {
        c = szChannel[i];
        if (c >= 32 && c <= 126)
            szChannelNameSan[iDest++] = c;
    }
    szChannelNameSan[iDest] = EOS;

    client_print(0, print_chat, "[#%s] %s: %s", szChannelNameSan, szDiscordName, szMessage);
}

listen_msg_slash(const JSON:jsonResponse)
{
    if (!json_object_has_value(jsonResponse, "command", JSONString))
    {
        server_print("[%s] Missing 'command' key in JSON message.", PLUGIN_NAME);
        return;
    }

    new szCommand[64];
    json_object_get_string(jsonResponse, "command", szCommand, charsmax(szCommand));


    if (equal(szCommand, "players"))
    {
        new szInteractionId[64];
        json_object_get_string(jsonResponse, "interactionid", szInteractionId, charsmax(szInteractionId));

        // Prepare and send player list information
        new iPlayers[32], num = 0;
        get_players(iPlayers, num);
        new JSON:jsonResponse = json_init_object();
        new JSON:jsonPlayersArray = json_init_array();

        json_object_set_number(jsonResponse, "type", _:MSG_SLASH);
        json_object_set_string(jsonResponse, "interactionid", szInteractionId);
        json_object_set_string(jsonResponse, "command", "players");

        for (new i = 0; i < num; i++)
        {
            new iPlayer = iPlayers[i];
            new szPlayerName[MAX_NAME_LENGTH];
            new iScore, iDeaths, iPing, iLoss;

            get_user_name(iPlayer, szPlayerName, charsmax(szPlayerName));
            iScore = get_user_frags(iPlayer);
            iDeaths = get_user_deaths(iPlayer);

            get_user_ping(iPlayer, iPing, iLoss);

            // Create a new player JSON object
            new JSON:jsonPlayer = json_init_object();

            // Set player name, score, deaths
            json_object_set_string(jsonPlayer, "name", szPlayerName);
            json_object_set_number(jsonPlayer, "score", iScore);
            json_object_set_number(jsonPlayer, "deaths", iDeaths);
            json_object_set_number(jsonPlayer, "ping", iPing);

            // Add the player JSON object to the players array
            json_array_append_value(jsonPlayersArray, jsonPlayer);

            // Free the individual player object after adding it to the array
            json_free(jsonPlayer);
        }

        // Set the players array in the response object
        json_object_set_value(jsonResponse, "players", jsonPlayersArray);

        new szResponse[MAX_BUFFER_LENGTH];
        json_serial_to_string(jsonResponse, szResponse, charsmax(szResponse), false);

        if (g_hSocket > 0 && socket_is_writable(g_hSocket, 0))
        {
            new iSentBytes = socket_send2(g_hSocket, szResponse, strlen(szResponse));
            if (iSentBytes < 0)
                server_print("[%s] Error sending command response.", PLUGIN_NAME);
            else
                server_print("[%s] Sent command response: %s", PLUGIN_NAME, szResponse);
        }
        else
        {
            server_print("[%s] Socket not writable. Command response not sent.", PLUGIN_NAME);
            remove_task(TASK_LISTEN);
            remove_task(TASK_SEND_SLOTINFO);
            establish_connection();
        }

        // Clean up
        json_free(jsonPlayersArray);
        json_free(jsonResponse);
    }
    else
    {
        server_print("[%s] Unknown command: %s", PLUGIN_NAME, szCommand);
    }
}

listen_msg_link(const JSON:jsonResponse)
{
    if (!json_object_has_value(jsonResponse, "authid", JSONString) ||
        !json_object_has_value(jsonResponse, "message", JSONString))
    {
        server_print("[%s] Missing 'message' key in JSON message.", PLUGIN_NAME);
        return;
    }

    new szAuthId[MAX_NAME_LENGTH];
    new szMessage[128];
    json_object_get_string(jsonResponse, "authid", szAuthId, charsmax(szAuthId));
    json_object_get_string(jsonResponse, "message", szMessage, charsmax(szMessage));

    new iPlayer = find_player_ex(FindPlayer_MatchAuthId, szAuthId);

    if (iPlayer)
        client_print(iPlayer, print_chat, "[%s] %s", PLUGIN_NAME, szMessage);

}


public handleSay(id)
{

    if (g_hSocket > 0 && socket_is_writable(g_hSocket, 0))
    {
        new szCmd[9];
        read_argv(0, szCmd, charsmax(szCmd));
        new bIsTeamChat = equali(szCmd, "say_team");

        new szMessage[MAX_BUFFER_LENGTH];
        read_args(szMessage, charsmax(szMessage));
        remove_quotes(szMessage);

        if (strlen(szMessage) == 0)
            return PLUGIN_CONTINUE;

        // if (szMessage[0] != '/')
        // return PLUGIN_CONTINUE;

        // if (szMessage[0] == '/' || szMessage[0] == '?')
        //     return PLUGIN_CONTINUE;

        new szPlayerName[MAX_NAME_LENGTH];
        get_user_name(id, szPlayerName, charsmax(szPlayerName));

        new szAuthId[MAX_NAME_LENGTH];
        get_user_authid(id, szAuthId, charsmax(szAuthId));

        new JSON:jsonMsgObj = json_init_object();

        json_object_set_number(jsonMsgObj, "type", _:MSG_CHAT);
        json_object_set_string(jsonMsgObj, "mode", bIsTeamChat ? "team" : "global");
        json_object_set_string(jsonMsgObj, "name", szPlayerName);
        json_object_set_string(jsonMsgObj, "authid", szAuthId);
        json_object_set_string(jsonMsgObj, "message", szMessage);

        new szSerializedMessage[MAX_BUFFER_LENGTH];
        json_serial_to_string(jsonMsgObj, szSerializedMessage, charsmax(szSerializedMessage), false);
        json_free(jsonMsgObj);

        new iSentBytes = socket_send2(g_hSocket, szSerializedMessage, strlen(szSerializedMessage));
        if (iSentBytes < 0)
            server_print("[%s] Error sending data to socket", PLUGIN_NAME);
        else
            server_print("[%s] Sent message: %s", PLUGIN_NAME, szSerializedMessage);
    }
    else
    {
        server_print("[%s] Socket not writable or disconnected, attempting to reconnect...", PLUGIN_NAME);
        remove_task(TASK_LISTEN);
        remove_task(TASK_SEND_SLOTINFO);
        establish_connection();
    }

    return PLUGIN_CONTINUE;
}

public cmdVerify(id)
{
    new Float:currentTime = get_gametime();
    const Float:fCooldownMax = 300.0;

    if (currentTime < g_fCooldown[id])
    {
        new Float:remainingTime = g_fCooldown[id] - currentTime;
        client_print(id, print_chat, "You must wait %.0f more seconds to use this command.", remainingTime);
        return PLUGIN_HANDLED;
    }

    g_fCooldown[id] = currentTime + fCooldownMax;

    if (g_hSocket > 0 && socket_is_writable(g_hSocket, 0))
    {
        new szMessage[MAX_BUFFER_LENGTH];
        read_args(szMessage, charsmax(szMessage));

        remove_quotes(szMessage);

        if (strlen(szMessage) == 0)
            return PLUGIN_CONTINUE;

        new szPlayerName[MAX_NAME_LENGTH];
        get_user_name(id, szPlayerName, charsmax(szPlayerName));

        new szAuthId[MAX_NAME_LENGTH];
        get_user_authid(id, szAuthId, charsmax(szAuthId));

        new JSON:jsonMsgObj = json_init_object();

        json_object_set_number(jsonMsgObj, "type", _:MSG_LINK);
        json_object_set_string(jsonMsgObj, "name", szPlayerName);
        json_object_set_string(jsonMsgObj, "authid", szAuthId);
        json_object_set_string(jsonMsgObj, "message", szMessage);

        new szSerializedMessage[MAX_BUFFER_LENGTH];
        json_serial_to_string(jsonMsgObj, szSerializedMessage, charsmax(szSerializedMessage), false);
        json_free(jsonMsgObj);

        new iSentBytes = socket_send2(g_hSocket, szSerializedMessage, strlen(szSerializedMessage));
        if (iSentBytes < 0)
            server_print("[%s] Error sending data to socket", PLUGIN_NAME);
        else
            server_print("[%s] Sent message: %s", PLUGIN_NAME, szSerializedMessage);
    }
    else
    {
        server_print("[%s] Socket not writable or disconnected, attempting to reconnect...", PLUGIN_NAME);
        remove_task(TASK_LISTEN);
        remove_task(TASK_SEND_SLOTINFO);
        establish_connection();
    }

    return PLUGIN_CONTINUE;
}


public plugin_end()
{
    remove_task(TASK_LISTEN);
    remove_task(TASK_SEND_SLOTINFO);
    socket_close(g_hSocket);
    g_hSocket = -1;
}

bool:IsHex(const str[])
{
    for (new i = 0; str[i] != 0; i++)
    {
        if (!( (str[i] >= '0' && str[i] <= '9') ||
               (str[i] >= 'a' && str[i] <= 'f') ||
               (str[i] >= 'A' && str[i] <= 'F') ))
            return false;
    }
    return true;
}


// bool:IsHexWithDashes(const str[])
// {
//     for (new i = 0; i < strlen(str); i++)
//     {
//         if (i == 8 || i == 13 || i == 18 || i == 23) // Dash positions
//         {
//             if (str[i] != '-')
//                 return false;
//         }
//         else if (!((str[i] >= '0' && str[i] <= '9') || (str[i] >= 'a' && str[i] <= 'f') || (str[i] >= 'A' && str[i] <= 'F')))
//         {
//             return false; // Not a valid hex digit
//         }
//     }
//     return true;
// }